<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux的使用</title>
    <link href="/2024/06/12/Linux/"/>
    <url>/2024/06/12/Linux/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Linux文件"><a href="#Linux文件" class="headerlink" title="Linux文件"></a>Linux文件</h2><p>Linux 系统中一切皆文件</p><h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240922140854301.png" alt="image-20240922140854301"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240922140906156.png" alt="image-20240922140906156"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240922140914261.png" alt="image-20240922140914261"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240922140921862.png" alt="image-20240922140921862"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240922140929714.png" alt="image-20240922140929714"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240922140935222.png" alt="image-20240922140935222"></p><h2 id="VIM编辑器"><a href="#VIM编辑器" class="headerlink" title="VIM编辑器"></a>VIM编辑器</h2><p>VI 是 Unix 操作系统和类 Unix 操作系统中最通用的文本编辑器。 </p><p>VIM 编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜 色辨别语法的正确性，方便程序设计。VIM 与 VI 编辑器完全兼容。</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240922153752876.png" alt="image-20240922153752876"></p><h3 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">vim</span> hello.txt<br></code></pre></td></tr></table></figure><p>进入文件后默认为一般模式，如果进入别的模式需要切换回一般模式，按esc即可</p><p>一般模式常用命令如下：</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240922153053809.png" alt="image-20240922153053809"></p><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><p>在一般模式下，按 <strong>i</strong> 即可进入编辑模式</p><p>注意了！通常在Linux中，按下这些按键时，在画面的左下方会出现『INSERT或 REPLACE』的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下 『Esc』这个按键即可退出编辑模式</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240922153541296.png" alt="image-20240922153541296"></p><h3 id="指令模式"><a href="#指令模式" class="headerlink" title="指令模式"></a>指令模式</h3><p>在一般模式下输入 <strong>：</strong>即可进入指令模式</p><p>在这个模式当中， 可以提供你『搜寻资料』的动作，而读取、存盘、大量取代字符、 离开 vi 、显示行号等动作是在此模式中达成的！</p><p>常用操作：</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240922153657574.png" alt="image-20240922153657574"></p><p>eg. <strong>wq!</strong> 强制保存退出</p><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><p>计算机中，一个正在执行的程序或命令，被叫做<strong>“进程”</strong>（process）。 </p><p>启动之后一只存在、常驻内存的进程，一般被称作<strong>“服务”</strong>（service）</p><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>1） 基本语法 </p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">systemctl start | <span class="hljs-type">stop</span> | <span class="hljs-type">restart</span> | <span class="hljs-type">status</span> 服务名 <br></code></pre></td></tr></table></figure><p>2） 经验技巧 查看服务的方法：&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system</p><p>3） 案例实操</p><p>（1）查看防火墙服务的状态 </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl status firewalld</span> <br></code></pre></td></tr></table></figure><p>（2）停止防火墙服务</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">systemctl stop firewalld <br></code></pre></td></tr></table></figure><p>（3）启动防火墙服务</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> firewalld <br></code></pre></td></tr></table></figure><p>（4）重启防火墙服务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl restart firewalld</span><br></code></pre></td></tr></table></figure><h3 id="systemctl-设置后台服务的自启配置"><a href="#systemctl-设置后台服务的自启配置" class="headerlink" title="systemctl 设置后台服务的自启配置"></a>systemctl 设置后台服务的自启配置</h3><p>1）基本语法  systemctl list-unit-files （功能描述：查看服务开机启动状态） </p><p>​  systemctl disable service_name （功能描述：关掉指定服务的自动启动）</p><pre><code class="hljs">                      systemctl enable service_name （功能描述：开启指定服务的自动启动） </code></pre><p>2）案例实操</p><p>开启&#x2F;关闭 iptables(防火墙)服务的自动启动</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> firewalld.service<br>systemctl <span class="hljs-built_in">disable</span> firewalld.service<br></code></pre></td></tr></table></figure><h3 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h3><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240925154106339.png" alt="image-20240925154106339"></p><p>CentOS7 的运行级别简化为: </p><p>multi-user.target 等价于原运行级别 3（多用户有网，无图形界面） </p><p>graphical.target 等价于原运行级别 5（多用户有网，有图形界面)</p><p>查看当前运行级别:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">systemctl <span class="hljs-keyword">get</span>-<span class="hljs-keyword">default</span><br></code></pre></td></tr></table></figure><p>修改当前运行级别:</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">systemctl</span> <span class="hljs-built_in">set-default</span> <span class="hljs-string">TARGET</span>.<span class="hljs-string">target</span> （这里 <span class="hljs-string">TARGET</span> 取 <span class="hljs-string">multi-user</span> 或者 <span class="hljs-string">graphical</span>)<br></code></pre></td></tr></table></figure><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><p>开机启动时关闭防火墙</p><p>(1) 查看防火墙开机启动状态   systemctl enable firewalld.service</p><p>(2) 设置开机时关闭防火墙    systemctl disable firewalld.service</p><h2 id="常用基本命令"><a href="#常用基本命令" class="headerlink" title="常用基本命令"></a>常用基本命令</h2><p>​Shell 可以看作是一个命令解释器，为我们提供了交互式的文本控制台界面。我们可以 通过终端控制台来输入命令，由 shell 进行解释并最终交给内核执行。 本章就将分类介绍 常用的基本 shell 命令。</p><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><table><thead><tr><th><strong>ctrl + c</strong></th><th><strong>停止进程</strong></th></tr></thead><tbody><tr><td><strong>ctrl + l</strong></td><td><strong>清屏，等同于 clear；彻底清屏是：reset</strong></td></tr><tr><td><strong>善于用 tab 键</strong></td><td><strong>提示(更重要的是可以防止敲错)</strong></td></tr><tr><td><strong>上下键</strong></td><td><strong>查找执行过的命令</strong></td></tr></tbody></table><h3 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h3><h4 id="pwd-显示当前工作目录的绝对路径"><a href="#pwd-显示当前工作目录的绝对路径" class="headerlink" title="pwd 显示当前工作目录的绝对路径"></a>pwd 显示当前工作目录的绝对路径</h4><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240925162930974.png" alt="image-20240925162930974"></p><h4 id="ls-列出目录的"><a href="#ls-列出目录的" class="headerlink" title="ls 列出目录的"></a>ls 列出目录的</h4><p>ls [选项] [目录或是文件]</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240925163041893.png" alt="image-20240925163041893"></p><h4 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd 切换目录"></a>cd 切换目录</h4><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240925163136386.png" alt="image-20240925163136386"></p><h4 id="mkdir-创建一个新的目录"><a href="#mkdir-创建一个新的目录" class="headerlink" title="mkdir 创建一个新的目录"></a>mkdir 创建一个新的目录</h4><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240925163327024.png" alt="image-20240925163327024"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240925163529170.png" alt="image-20240925163529170"></p><h4 id="rmdir-删除一个空的目录"><a href="#rmdir-删除一个空的目录" class="headerlink" title="rmdir 删除一个空的目录"></a>rmdir 删除一个空的目录</h4><p>要求必须是空的文件夹</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240925163744485.png" alt="image-20240925163744485"></p><h4 id="touch-创建空文件"><a href="#touch-创建空文件" class="headerlink" title="touch 创建空文件"></a>touch 创建空文件</h4><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240925163828153.png" alt="image-20240925163828153"></p><h4 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp 复制文件或目录"></a>cp 复制文件或目录</h4><p>cp [选项] source dest （功能描述：复制source文件到dest）</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20240925172528042.png" alt="image-20240925172528042"></p><h4 id="rm-删除文件或目录"><a href="#rm-删除文件或目录" class="headerlink" title="rm 删除文件或目录"></a>rm 删除文件或目录</h4><p>rm [选项] deleteFile （功能描述：递归删除目录中所有内容）</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007153021862.png" alt="image-20241007153021862"></p><p>eg.</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007153312137.png" alt="image-20241007153312137"></p><h4 id="mv-移动文件与目录或重命名"><a href="#mv-移动文件与目录或重命名" class="headerlink" title="mv 移动文件与目录或重命名"></a>mv 移动文件与目录或重命名</h4><p>（1）mv oldNameFile newNameFile （功能描述：重命名） </p><p>（2）mv &#x2F;temp&#x2F;movefile &#x2F;targetFolder （功能描述：移动文件）</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007154826000.png" alt="image-20241007154826000"></p><h4 id="cat-查看文件内容"><a href="#cat-查看文件内容" class="headerlink" title="cat 查看文件内容"></a>cat 查看文件内容</h4><p>查看文件内容，从第一行开始显示</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007155904352.png" alt="image-20241007155904352"></p><h4 id="输出重定向和-追加"><a href="#输出重定向和-追加" class="headerlink" title="&gt; 输出重定向和 &gt;&gt; 追加"></a>&gt; 输出重定向和 &gt;&gt; 追加</h4><p>（1）ls -l &gt; 文件 （功能描述：列表的内容写入文件 a.txt 中（覆盖写）） </p><p>（2）ls -al &gt;&gt; 文件 （功能描述：列表的内容追加到文件 aa.txt 的末尾） </p><p>（3）cat 文件 1 &gt; 文件 2 （功能描述：将文件 1 的内容覆盖到文件 2） </p><p>（4）echo “内容” &gt;&gt;</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007161954705.png" alt="image-20241007161954705"></p><h4 id="ln-软链接"><a href="#ln-软链接" class="headerlink" title="ln 软链接"></a>ln 软链接</h4><p>软链接也称为符号链接，类似于 windows 里的快捷方式，有自己的数据块，主要存放 了链接其他文件的路径。</p><p>1）基本语法 ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007162242278.png" alt="image-20241007162242278"></p><h4 id="history-查看已经执行过历史命令"><a href="#history-查看已经执行过历史命令" class="headerlink" title="history 查看已经执行过历史命令"></a>history 查看已经执行过历史命令</h4><h3 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h3><p>data显示当前时间 </p><p>cal显示当前日历</p><h3 id="用户权限类"><a href="#用户权限类" class="headerlink" title="用户权限类"></a>用户权限类</h3><h4 id="useradd-添加新用户"><a href="#useradd-添加新用户" class="headerlink" title="useradd 添加新用户"></a>useradd 添加新用户</h4><p>useradd 用户名 （功能描述：添加新用户） </p><p>useradd -g 组名 用户名 （功能描述：添加新用户到某个组）</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007170423092.png" alt="image-20241007170423092"></p><h4 id="passwd-设置用户密码"><a href="#passwd-设置用户密码" class="headerlink" title="passwd 设置用户密码"></a>passwd 设置用户密码</h4><p>passwd 用户名 （功能描述：设置用户密码）</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007170523875.png" alt="image-20241007170523875"></p><h4 id="id-查看用户是否存在"><a href="#id-查看用户是否存在" class="headerlink" title="id 查看用户是否存在"></a>id 查看用户是否存在</h4><p>id 用户名</p><h4 id="su-切换用户"><a href="#su-切换用户" class="headerlink" title="su 切换用户"></a>su 切换用户</h4><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007170936012.png" alt="image-20241007170936012"></p><h4 id="userdel-删除用户"><a href="#userdel-删除用户" class="headerlink" title="userdel 删除用户"></a>userdel 删除用户</h4><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007171126730.png" alt="image-20241007171126730"></p><h4 id="who-查看登录用户信息"><a href="#who-查看登录用户信息" class="headerlink" title="who 查看登录用户信息"></a>who 查看登录用户信息</h4><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007171321240.png" alt="image-20241007171321240"></p><h4 id="sudo-设置普通用户具有-root-权限"><a href="#sudo-设置普通用户具有-root-权限" class="headerlink" title="sudo 设置普通用户具有 root 权限"></a>sudo 设置普通用户具有 root 权限</h4><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007222756731.png" alt="image-20241007222756731"></p><h4 id="usermod-修改用户"><a href="#usermod-修改用户" class="headerlink" title="usermod 修改用户"></a>usermod 修改用户</h4><p>usermod -g 用户组 用户名</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007223130004.png" alt="image-20241007223130004"></p><h4 id="groupadd-新增组"><a href="#groupadd-新增组" class="headerlink" title="groupadd 新增组"></a>groupadd 新增组</h4><p>groupadd 组名</p><h4 id="groupdel-删除"><a href="#groupdel-删除" class="headerlink" title="groupdel 删除"></a>groupdel 删除</h4><p>groupdel 组名</p><h4 id="groupmod-修改组"><a href="#groupmod-修改组" class="headerlink" title="groupmod 修改组"></a>groupmod 修改组</h4><p>groupmod -n 新组名 老组名</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007223324848.png" alt="image-20241007223324848"></p><h3 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h3><h4 id="find-查找文件或者目录"><a href="#find-查找文件或者目录" class="headerlink" title="find 查找文件或者目录"></a>find 查找文件或者目录</h4><p>find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件显示在终端。</p><p>find [搜索范围] [选项]</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007225140531.png" alt="image-20241007225140531"></p><h4 id="locate-快速定位文件路径（快）"><a href="#locate-快速定位文件路径（快）" class="headerlink" title="locate 快速定位文件路径（快）"></a>locate 快速定位文件路径（快）</h4><p>locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给 定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确 度，管理员必须定期更新 locate 时刻</p><p>locate 搜索文件</p><p><strong>注意：由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创 建 locate 数据库。</strong></p><h3 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h3><h4 id="gzip-gunzip-压缩"><a href="#gzip-gunzip-压缩" class="headerlink" title="gzip&#x2F;gunzip 压缩"></a>gzip&#x2F;gunzip 压缩</h4><p>gzip 文件 （功能描述：压缩文件，只能将文件压缩为*.gz 文件）</p><p>gunzip 文件.gz （功能描述：解压缩文件命令）</p><p>注意：</p><p>（1）只能压缩文件不能压缩目录 </p><p>（2）不保留原来的文件 </p><p>（3）同时多个文件会产生多个压缩包</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007225922203.png" alt="image-20241007225922203"></p><h4 id="zip-unzip-压缩"><a href="#zip-unzip-压缩" class="headerlink" title="zip&#x2F;unzip 压缩"></a>zip&#x2F;unzip 压缩</h4><p>zip [选项] XXX.zip 将要压缩的内容 （功能描述：压缩文件和目录的命令）</p><p>unzip [选项] XXX.zip （功能描述：解压缩文件）</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007230144970.png" alt="image-20241007230144970"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007230222775.png" alt="image-20241007230222775"></p><h4 id="tar-打包"><a href="#tar-打包" class="headerlink" title="tar 打包"></a>tar 打包</h4><p>tar [选项] XXX.tar.gz 将要打包进去的内容 （功能描述：打包目录，压缩后的 文件格式.tar.gz）</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007230342876.png" alt="image-20241007230342876"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007230445312.png" alt="image-20241007230445312"></p><h3 id="磁盘查看和分区类"><a href="#磁盘查看和分区类" class="headerlink" title="磁盘查看和分区类"></a>磁盘查看和分区类</h3><h4 id="du-查看文件和目录占用的磁盘空间"><a href="#du-查看文件和目录占用的磁盘空间" class="headerlink" title="du 查看文件和目录占用的磁盘空间"></a>du 查看文件和目录占用的磁盘空间</h4><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007231353758.png" alt="image-20241007231353758"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241007233036452.png" alt="image-20241007233036452"></p><h4 id="df-查看磁盘空间使用情况"><a href="#df-查看磁盘空间使用情况" class="headerlink" title="df 查看磁盘空间使用情况"></a>df 查看磁盘空间使用情况</h4><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008103455967.png" alt="image-20241008103455967"></p><h4 id="fdisk-分区"><a href="#fdisk-分区" class="headerlink" title="fdisk 分区"></a>fdisk 分区</h4><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008103737904.png" alt="image-20241008103737904"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008103747286.png" alt="image-20241008103747286"></p><h3 id="进程管理类"><a href="#进程管理类" class="headerlink" title="进程管理类"></a>进程管理类</h3><p>进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地 址空间，并占用一定的系统资源</p><h4 id="ps-查看当前系统进程状态"><a href="#ps-查看当前系统进程状态" class="headerlink" title="ps 查看当前系统进程状态"></a>ps 查看当前系统进程状态</h4><p>ps aux | grep xxx （功能描述：查看系统中所有进程） </p><p>ps -ef | grep xxx （功能描述：可以查看子父进程之间的关系）</p><p>注：grep<strong>是筛选操作</strong></p><p><font color='pink'>如果想查看进程的 CPU 占用率和内存占用率，可以使用 aux; 如果想查看进程的父进程 ID 可以使用 ef</font></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008105344538.png" alt="image-20241008105344538"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008105417423.png" alt="image-20241008105417423"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008105425790.png" alt="image-20241008105425790"></p><h4 id="kill-终止进程"><a href="#kill-终止进程" class="headerlink" title="kill 终止进程"></a>kill 终止进程</h4><p>kill [选项] 进程号 （功能描述：通过进程号杀死进程） </p><p>killall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这 在系统因负载过大而变得很慢时很有用）</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008105616048.png" alt="image-20241008105616048"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008105955743.png" alt="image-20241008105955743"></p><h4 id="pstree-查看进程树"><a href="#pstree-查看进程树" class="headerlink" title="pstree 查看进程树"></a>pstree 查看进程树</h4><p>pstree [选项]</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008112538492.png" alt="image-20241008112538492"></p><h4 id="top-实时监控系统进程状态"><a href="#top-实时监控系统进程状态" class="headerlink" title="top 实时监控系统进程状态"></a>top 实时监控系统进程状态</h4><p>top [选项]</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008112857404.png" alt="image-20241008112857404"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008112903343.png" alt="image-20241008112903343"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008112913160.png" alt="image-20241008112913160"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008112931081.png" alt="image-20241008112931081"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008112936276.png" alt="image-20241008112936276"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008112947117.png" alt="image-20241008112947117"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008112953578.png" alt="image-20241008112953578"></p><h4 id="netstat-显示网络状态和端口占用信息"><a href="#netstat-显示网络状态和端口占用信息" class="headerlink" title="netstat 显示网络状态和端口占用信息"></a>netstat 显示网络状态和端口占用信息</h4><p>netstat -anp | grep 进程号 （功能描述：查看该进程网络信息）</p><p>netstat –nlp | grep 端口号 （功能描述：查看网络端口号占用情况）</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008113147744.png" alt="image-20241008113147744"></p><p>通过进程号查看sshd进程的网络信息</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008113209875.png" alt="image-20241008113209875"></p><p>查看某端口号是否被占用</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008113227169.png" alt="image-20241008113227169"></p><h3 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h3><h4 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h4><p>RPM（RedHat Package Manager），RedHat软件包管理工具，类似windows里面的setup.exe 是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。</p><h4 id="RPM-查询命令（rpm-qa"><a href="#RPM-查询命令（rpm-qa" class="headerlink" title="RPM 查询命令（rpm -qa)"></a>RPM 查询命令（rpm -qa)</h4><p>rpm -qa （功能描述：查询所安装的所有 rpm 软件包)</p><p>由于软件包比较多，一般都会采取过滤。rpm -qa | grep rpm软件包</p><h4 id="RPM-卸载命令（rpm-e"><a href="#RPM-卸载命令（rpm-e" class="headerlink" title="RPM 卸载命令（rpm -e)"></a>RPM 卸载命令（rpm -e)</h4><p>（1）rpm -e RPM软件包 （2） rpm -e –nodeps 软件包</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008114218119.png" alt="image-20241008114218119"></p><p> rpm -e –nodeps 软件包 ,可能会导致使用软件包的软件无法正常工作</p><h4 id="RPM-安装命令（rpm-ivh）"><a href="#RPM-安装命令（rpm-ivh）" class="headerlink" title="RPM 安装命令（rpm -ivh）"></a>RPM 安装命令（rpm -ivh）</h4><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008114310861.png" alt="image-20241008114310861"></p><h4 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h4><p>YUM（全称为 Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 CentOS 中的 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包 并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装,类似maven</p><p>yum [选项] [参数]</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008114428190.png" alt="image-20241008114428190"></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008114434602.png" alt="image-20241008114434602"></p><p>eg.采用 yum 方式安装 firefox</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/images/image-20241008114519499.png" alt="image-20241008114519499"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的使用</title>
    <link href="/2024/05/06/Redis/"/>
    <url>/2024/05/06/Redis/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-Redis入门"><a href="#1-Redis入门" class="headerlink" title="1. Redis入门"></a>1. Redis入门</h2><h3 id="1-1-Redis简介"><a href="#1-1-Redis简介" class="headerlink" title="1.1 Redis简介"></a>1.1 Redis简介</h3><p>Redis是一个基于<strong>内存</strong>的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的<strong>存储中间件</strong>。</p><p><strong>官网：</strong><a href="https://redis.io/">https://redis.io</a><br><strong>中文网：</strong><a href="https://www.redis.net.cn/">https://www.redis.net.cn/</a></p><p><strong>key-value结构存储：</strong></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20221130173459174.png" alt="image-20221130173459174"> </p><p><strong>主要特点：</strong></p><ul><li>基于内存存储，读写性能高  </li><li>适合存储热点数据（热点商品、资讯、新闻）</li><li>企业应用广泛</li></ul><p>安装后重点文件说明：</p><ul><li>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;src&#x2F;redis-server：Redis服务启动脚本</li><li>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;src&#x2F;redis-cli：Redis客户端脚本</li><li>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;redis.conf：Redis配置文件</li></ul><h4 id="1-3-1-服务启动命令"><a href="#1-3-1-服务启动命令" class="headerlink" title="1.3.1 服务启动命令"></a>1.3.1 服务启动命令</h4><p><strong>redis-server.exe redis.windows.conf</strong></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20240820165018602.png" alt="image-20240820165018602"> </p><p>Redis服务默认端口号为 <strong>6379</strong> ，通过快捷键<strong>Ctrl + C</strong> 即可停止Redis服务</p><p>当Redis服务启动成功后，可通过客户端进行连接。</p><p>通过redis-cli.exe命令默认连接的是本地的redis服务，并且使用默认6379端口。也可以通过指定如下参数连接：</p><ul><li>-h ip地址</li><li>-p 端口号</li><li>-a 密码（如果需要）</li></ul><h2 id="2-Redis数据类型"><a href="#2-Redis数据类型" class="headerlink" title="2. Redis数据类型"></a>2. Redis数据类型</h2><h3 id="2-1-五种常用数据类型介绍"><a href="#2-1-五种常用数据类型介绍" class="headerlink" title="2.1 五种常用数据类型介绍"></a>2.1 五种常用数据类型介绍</h3><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</p><ul><li>字符串 string</li><li>哈希 hash</li><li>列表 list</li><li>集合 set</li><li>有序集合 sorted set &#x2F; zset</li></ul><h3 id="2-2-各种数据类型特点"><a href="#2-2-各种数据类型特点" class="headerlink" title="2.2 各种数据类型特点"></a>2.2 各种数据类型特点</h3><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20240820165138765.png" alt="image-20240820165138765"></p><p><strong>解释说明：</strong></p><ul><li>字符串(string)：普通字符串，Redis中最简单的数据类型</li><li>哈希(hash)：也叫散列，类似于Java中的HashMap结构</li><li>列表(list)：按照插入顺序排序，可以有重复元素，类似于Java中的LinkedList</li><li>集合(set)：无序集合，没有重复元素，类似于Java中的HashSet</li><li>有序集合(sorted set&#x2F;zset)：集合中每个元素关联一个分数(score)，根据分数升序排序，没有重复元素</li></ul><h2 id="3-Redis常用命令"><a href="#3-Redis常用命令" class="headerlink" title="3. Redis常用命令"></a>3. Redis常用命令</h2><h3 id="3-1-字符串操作命令"><a href="#3-1-字符串操作命令" class="headerlink" title="3.1 字符串操作命令"></a>3.1 字符串操作命令</h3><p>Redis 中字符串类型常用命令：</p><ul><li><strong>SET</strong> key value          设置指定key的值</li><li><strong>GET</strong> key                                        获取指定key的值</li><li><strong>SETEX</strong> key seconds value         设置指定key的值，并将 key 的过期时间设为 seconds 秒</li><li><strong>SETNX</strong> key value                        只有在 key    不存在时设置 key 的值</li></ul><p>更多命令可以参考Redis中文网：<a href="https://www.redis.net.cn/">https://www.redis.net.cn</a></p><h3 id="3-2-哈希操作命令"><a href="#3-2-哈希操作命令" class="headerlink" title="3.2 哈希操作命令"></a>3.2 哈希操作命令</h3><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p><ul><li><strong>HSET</strong> key field value             将哈希表 key 中的字段 field 的值设为 value</li><li><strong>HGET</strong> key field                       获取存储在哈希表中指定字段的值</li><li><strong>HDEL</strong> key field                       删除存储在哈希表中的指定字段</li><li><strong>HKEYS</strong> key                              获取哈希表中所有字段</li><li><strong>HVALS</strong> key                              获取哈希表中所有值</li></ul><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20240821140401682.png" alt="image-20240821140401682"></p><h3 id="3-3-列表操作命令"><a href="#3-3-列表操作命令" class="headerlink" title="3.3 列表操作命令"></a>3.3 列表操作命令</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：</p><ul><li><strong>LPUSH</strong> key value1 [value2]         将一个或多个值插入到列表头部</li><li><strong>LRANGE</strong> key start stop                获取列表指定范围内的元素</li><li><strong>RPOP</strong> key                                       移除并获取列表最后一个元素</li><li><strong>LLEN</strong> key                                        获取列表长度</li><li><strong>BRPOP</strong> key1 [key2 ] timeout       移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超    时或发现可弹出元素为止</li></ul><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20240821140415208.png" alt="image-20240821140415208"></p><h3 id="3-4-集合操作命令"><a href="#3-4-集合操作命令" class="headerlink" title="3.4 集合操作命令"></a>3.4 集合操作命令</h3><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：</p><ul><li><strong>SADD</strong> key member1 [member2]            向集合添加一个或多个成员</li><li><strong>SMEMBERS</strong> key                                         返回集合中的所有成员</li><li><strong>SCARD</strong> key                                                  获取集合的成员数</li><li><strong>SINTER</strong> key1 [key2]                                   返回给定所有集合的交集</li><li><strong>SUNION</strong> key1 [key2]                                 返回所有给定集合的并集</li><li><strong>SREM</strong> key member1 [member2]            移除集合中一个或多个成员</li></ul><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20240821140450063.png" alt="image-20240821140450063"></p><h3 id="3-5-有序集合操作命令"><a href="#3-5-有序集合操作命令" class="headerlink" title="3.5 有序集合操作命令"></a>3.5 有序集合操作命令</h3><p>Redis有序集合是string类型元素的集合，且不允许有重复成员。每个元素都会关联一个double类型的分数。常用命令：</p><p>常用命令：</p><ul><li><strong>ZADD</strong> key score1 member1 [score2 member2]     向有序集合添加一个或多个成员</li><li><strong>ZRANGE</strong> key start stop [WITHSCORES]                     通过索引区间返回有序集合中指定区间内的成员</li><li><strong>ZINCRBY</strong> key increment member                              有序集合中对指定成员的分数加上增量 increment</li><li><strong>ZREM</strong> key member [member …]                                移除有序集合中的一个或多个成员</li></ul><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20240821140503592.png" alt="image-20240821140503592"></p><h3 id="3-6-通用命令"><a href="#3-6-通用命令" class="headerlink" title="3.6 通用命令"></a>3.6 通用命令</h3><p>Redis的通用命令是不分数据类型的，都可以使用的命令：</p><ul><li>KEYS pattern 查找所有符合给定模式( pattern)的 key </li><li>EXISTS key 检查给定 key 是否存在</li><li>TYPE key 返回 key 所储存的值的类型</li><li>DEL key 该命令用于在 key 存在是删除 key</li></ul><h2 id="4-在Java中操作Redis"><a href="#4-在Java中操作Redis" class="headerlink" title="4.在Java中操作Redis"></a>4.在Java中操作Redis</h2><h3 id="4-1-Redis的Java客户端"><a href="#4-1-Redis的Java客户端" class="headerlink" title="4.1 Redis的Java客户端"></a>4.1 Redis的Java客户端</h3><p>前面我们讲解了Redis的常用命令，这些命令是我们操作Redis的基础，那么我们在java程序中应该如何操作Redis呢？这就需要使用Redis的Java客户端，就如同我们使用JDBC操作MySQL数据库一样。</p><p>Redis 的 Java 客户端很多，常用的几种：</p><ul><li>Jedis</li><li>Lettuce</li><li>Spring Data Redis</li></ul><p>Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。</p><p>Spring Boot提供了对应的Starter，maven坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Spring Data Redis中提供了一个高度封装的类：<strong>RedisTemplate</strong>，对相关api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下：</p><ul><li>ValueOperations：string数据操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：hash类型的数据操作</li><li>ListOperations：list类型的数据操作</li></ul><h4 id="4-2-2-环境搭建"><a href="#4-2-2-环境搭建" class="headerlink" title="4.2.2 环境搭建"></a>4.2.2 环境搭建</h4><p>进入到sky-server模块</p><p><strong>1). 导入Spring Data Redis的maven坐标(已完成)</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2). 配置Redis数据源</strong></p><p>在application-dev.yml中添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sky:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>解释说明：</strong></p><p>database:指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。</p><p>可以通过修改Redis配置文件来指定数据库的数量。</p><p>在application.yml中添加读取application-dev.yml中的相关Redis配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">$&#123;sky.redis.host&#125;</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-string">$&#123;sky.redis.port&#125;</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">$&#123;sky.redis.password&#125;</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-string">$&#123;sky.redis.database&#125;</span><br></code></pre></td></tr></table></figure><p><strong>3). 编写配置类，创建RedisTemplate对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.config;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始创建redis模板对象...&quot;</span>);<br>        <span class="hljs-type">RedisTemplate</span> <span class="hljs-variable">redisTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>();<br>        <span class="hljs-comment">//设置redis的连接工厂对象</span><br>        redisTemplate.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-comment">//把需要的value字段改为这个从redis客户端看到的就不再是二进制了</span><br>        redisTemplate.setValueSerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>());<br>        <span class="hljs-comment">//设置redis key的序列化器</span><br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释说明：</strong></p><p>当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为</p><p>JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别，故设置为</p><p>StringRedisSerializer序列化器。</p><p><strong>4). 通过RedisTemplate对象操作Redis</strong></p><p>在test下新建测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.test;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.*;<br><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringDataRedisTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedisTemplate</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(redisTemplate);<br>        <span class="hljs-comment">//string数据操作</span><br>        <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>        <span class="hljs-comment">//hash类型的数据操作</span><br>        <span class="hljs-type">HashOperations</span> <span class="hljs-variable">hashOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForHash();<br>        <span class="hljs-comment">//list类型的数据操作</span><br>        <span class="hljs-type">ListOperations</span> <span class="hljs-variable">listOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForList();<br>        <span class="hljs-comment">//set类型数据操作</span><br>        <span class="hljs-type">SetOperations</span> <span class="hljs-variable">setOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForSet();<br>        <span class="hljs-comment">//zset类型数据操作</span><br>        <span class="hljs-type">ZSetOperations</span> <span class="hljs-variable">zSetOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForZSet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明RedisTemplate对象注入成功，并且通过该RedisTemplate对象获取操作5种数据类型相关对象。</p><p>上述环境搭建完毕后，接下来，我们就来具体对常见5种数据类型进行操作。</p><h4 id="4-2-3-操作常见类型数据"><a href="#4-2-3-操作常见类型数据" class="headerlink" title="4.2.3 操作常见类型数据"></a>4.2.3 操作常见类型数据</h4><h5 id="1-操作字符串类型数据"><a href="#1-操作字符串类型数据" class="headerlink" title="1). 操作字符串类型数据"></a><strong>1). 操作字符串类型数据</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 操作字符串类型的数据</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">// set get setex setnx</span><br>       redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;小明&quot;</span>);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">city</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>       System.out.println(city);<br>       redisTemplate.opsForValue().set(<span class="hljs-string">&quot;code&quot;</span>,<span class="hljs-string">&quot;1234&quot;</span>,<span class="hljs-number">3</span>, TimeUnit.MINUTES);<br>       redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>);<br>       redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="2-操作哈希类型数据"><a href="#2-操作哈希类型数据" class="headerlink" title="2). 操作哈希类型数据"></a><strong>2). 操作哈希类型数据</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 操作哈希类型的数据</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">//hset hget hdel hkeys hvals</span><br>       <span class="hljs-type">HashOperations</span> <span class="hljs-variable">hashOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForHash();<br><br>       hashOperations.put(<span class="hljs-string">&quot;100&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>       hashOperations.put(<span class="hljs-string">&quot;100&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;20&quot;</span>);<br><br>       <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) hashOperations.get(<span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);<br>       System.out.println(name);<br><br>       <span class="hljs-type">Set</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> hashOperations.keys(<span class="hljs-string">&quot;100&quot;</span>);<br>       System.out.println(keys);<br><br>       <span class="hljs-type">List</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> hashOperations.values(<span class="hljs-string">&quot;100&quot;</span>);<br>       System.out.println(values);<br><br>       hashOperations.delete(<span class="hljs-string">&quot;100&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="3-操作列表类型数据"><a href="#3-操作列表类型数据" class="headerlink" title="3). 操作列表类型数据"></a><strong>3). 操作列表类型数据</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 操作列表类型的数据</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testList</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">//lpush lrange rpop llen</span><br>       <span class="hljs-type">ListOperations</span> <span class="hljs-variable">listOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForList();<br><br>       listOperations.leftPushAll(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);<br>       listOperations.leftPush(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>);<br><br>       <span class="hljs-type">List</span> <span class="hljs-variable">mylist</span> <span class="hljs-operator">=</span> listOperations.range(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>       System.out.println(mylist);<br><br>       listOperations.rightPop(<span class="hljs-string">&quot;mylist&quot;</span>);<br><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> listOperations.size(<span class="hljs-string">&quot;mylist&quot;</span>);<br>       System.out.println(size);<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="4-操作集合类型数据"><a href="#4-操作集合类型数据" class="headerlink" title="4). 操作集合类型数据"></a><strong>4). 操作集合类型数据</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 操作集合类型的数据</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSet</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">//sadd smembers scard sinter sunion srem</span><br>       <span class="hljs-type">SetOperations</span> <span class="hljs-variable">setOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForSet();<br><br>       setOperations.add(<span class="hljs-string">&quot;set1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>);<br>       setOperations.add(<span class="hljs-string">&quot;set2&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>);<br><br>       <span class="hljs-type">Set</span> <span class="hljs-variable">members</span> <span class="hljs-operator">=</span> setOperations.members(<span class="hljs-string">&quot;set1&quot;</span>);<br>       System.out.println(members);<br><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> setOperations.size(<span class="hljs-string">&quot;set1&quot;</span>);<br>       System.out.println(size);<br><br>       <span class="hljs-type">Set</span> <span class="hljs-variable">intersect</span> <span class="hljs-operator">=</span> setOperations.intersect(<span class="hljs-string">&quot;set1&quot;</span>, <span class="hljs-string">&quot;set2&quot;</span>);<br>       System.out.println(intersect);<br><br>       <span class="hljs-type">Set</span> <span class="hljs-variable">union</span> <span class="hljs-operator">=</span> setOperations.union(<span class="hljs-string">&quot;set1&quot;</span>, <span class="hljs-string">&quot;set2&quot;</span>);<br>       System.out.println(union);<br><br>       setOperations.remove(<span class="hljs-string">&quot;set1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="5-操作有序集合类型数据"><a href="#5-操作有序集合类型数据" class="headerlink" title="5). 操作有序集合类型数据"></a><strong>5). 操作有序集合类型数据</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 操作有序集合类型的数据</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testZset</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">//zadd zrange zincrby zrem</span><br>       <span class="hljs-type">ZSetOperations</span> <span class="hljs-variable">zSetOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForZSet();<br><br>       zSetOperations.add(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">10</span>);<br>       zSetOperations.add(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">12</span>);<br>       zSetOperations.add(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">9</span>);<br><br>       <span class="hljs-type">Set</span> <span class="hljs-variable">zset1</span> <span class="hljs-operator">=</span> zSetOperations.range(<span class="hljs-string">&quot;zset1&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>       System.out.println(zset1);<br><br>       zSetOperations.incrementScore(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">10</span>);<br><br>       zSetOperations.remove(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="6-通用命令操作"><a href="#6-通用命令操作" class="headerlink" title="6). 通用命令操作"></a><strong>6). 通用命令操作</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 通用命令操作</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCommon</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">//keys exists type del</span><br>       <span class="hljs-type">Set</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> redisTemplate.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>       System.out.println(keys);<br><br>       <span class="hljs-type">Boolean</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisTemplate.hasKey(<span class="hljs-string">&quot;name&quot;</span>);<br>       <span class="hljs-type">Boolean</span> <span class="hljs-variable">set1</span> <span class="hljs-operator">=</span> redisTemplate.hasKey(<span class="hljs-string">&quot;set1&quot;</span>);<br><br>       <span class="hljs-keyword">for</span> (Object key : keys) &#123;<br>           <span class="hljs-type">DataType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> redisTemplate.type(key);<br>           System.out.println(type.name());<br>       &#125;<br><br>       redisTemplate.delete(<span class="hljs-string">&quot;mylist&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker的使用</title>
    <link href="/2024/03/11/Docker/"/>
    <url>/2024/03/11/Docker/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h3><p>基于Centos7 </p><p><strong>步骤：</strong></p><p>​1.用阿里云的：yum-config-manager –add-repo <a href="https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a> </p><p>​2.更新yum软件包：yum makecache fast </p><p>​3.安装社区版docker：yum install docker-ce docker-ce-cli containerd.io</p><p><strong>启动和校验：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 启动Docker</span><br>systemctl start docker<br><br><span class="hljs-comment"># 停止Docker</span><br>systemctl stop docker<br><br><span class="hljs-comment"># 重启</span><br>systemctl restart docker<br><br><span class="hljs-comment"># 设置开机自启</span><br>systemctl <span class="hljs-built_in">enable</span> docker<br><br><span class="hljs-comment"># 执行docker ps命令，如果不报错，说明安装启动成功</span><br>docker ps<br></code></pre></td></tr></table></figure><h4 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a>修改镜像源</h4><p>由于国内docker镜像源都被封禁，所以使用github大佬的。</p><p>使用教程b站视频：</p><p><a href="https://www.bilibili.com/video/BV1Em421L7xQ/?spm_id_from=333.1387.homepage.video_card.click&amp;amp;vd_source=06c70d306edf148bb957ae5f547cb85c">修改镜像源</a></p><p>eg.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -P m.daocloud.io/docker.io/library/nginx<br></code></pre></td></tr></table></figure><p>安装MySQL</p><p>注意：这里是提前引用了黑马的文件才这样下载的，并且还创建了hm-net的网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d \<br>  --name mysql \<br>  -p 3306:3306 \<br>  -e TZ=Asia/Shanghai \<br>  -e MYSQL_ROOT_PASSWORD=123 \<br>  -v /root/mysql/data:/var/lib/mysql \<br>  -v /root/mysql/conf:/etc/mysql/conf.d \<br>  -v /root/mysql/init:/docker-entrypoint-initdb.d \<br>  --network hm-net\<br>  mysql:5.7.19<br></code></pre></td></tr></table></figure><p><font color='pink'>注：这里使用大佬的镜像源的时候，拉取时候记得取别名，不然镜像名字默认的是地址，贼长一串！</font></p><p>现在不知道什么情况，不太行，用的下面这个</p><p><a href="https://blog.csdn.net/llc580231/article/details/139979603">docker镜像加速源配置，目前可用镜像源列举(10月10日更新最新可用)_docker可用的镜像源-CSDN博客</a></p><h3 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h3><p>利用Docker快速的安装了MySQL，非常的方便，不过我们执行的命令到底是什么意思呢</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">docker run <span class="hljs-literal">-d</span> \<br>  <span class="hljs-literal">--name</span> mysql \<br>  <span class="hljs-literal">-p</span> <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> \<br>  <span class="hljs-literal">-e</span> TZ=Asia/Shanghai \<br>  <span class="hljs-literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="hljs-number">123</span> \<br>  mysql<br></code></pre></td></tr></table></figure><p>解读：</p><ul><li><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</li><li><code>--name mysql </code> : 给容器起个名字叫<code>mysql</code>，你可以叫别的</li><li><code>-p 3306:3306</code> : 设置端口映射。<ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将<strong><strong>宿主机</strong></strong>端口****映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数<ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li></ul></li><li><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像<ul><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li></ul></li></ul><p>​     镜像的名称不是随意的，而是要到DockerRegistry中寻找，镜像运行时的配置也不是随意的，要参考镜像的帮助文档，这些在DockerHub网站或者软件的官方网站中都能找到。</p><h3 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h3><p>其中，比较常见的命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker pull</td><td align="left">拉取镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="left">docker push</td><td align="left">推送镜像到DockerRegistry</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="left">docker images</td><td align="left">查看本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/">docker images</a></td></tr><tr><td align="left">docker rmi</td><td align="left">删除本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="left">docker run</td><td align="left">创建并运行容器（不能重复创建）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="left">docker stop</td><td align="left">停止指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="left">docker start</td><td align="left">启动指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="left">docker restart</td><td align="left">重新启动容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="left">docker rm</td><td align="left">删除指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="left">docker ps</td><td align="left">查看容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="left">docker logs</td><td align="left">查看容器运行日志</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="left">docker exec</td><td align="left">进入容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="left">docker save</td><td align="left">保存镜像到本地压缩文件</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="left">docker load</td><td align="left">加载本地压缩文件到镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="left">docker inspect</td><td align="left">查看容器详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20241009105907237.png" alt="image-20241009105907237"></p><p>下面以下载使用Nginx为例子：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-comment"># 第1步，去DockerHub查看nginx镜像仓库及相关信息</span><br><br><span class="hljs-comment"># 第2步，拉取Nginx镜像</span><br>docker pull nginx<br><br><span class="hljs-comment"># 第3步，查看镜像</span><br>docker images<br><span class="hljs-comment"># 结果如下：</span><br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>nginx        latest    <span class="hljs-number">605</span>c77e624dd   <span class="hljs-number">16</span> months ago   <span class="hljs-number">141</span>MB<br>mysql        latest    <span class="hljs-number">3218</span>b38490ce   <span class="hljs-number">17</span> months ago   <span class="hljs-number">516</span>MB<br><br><span class="hljs-comment"># 第4步，创建并允许Nginx容器</span><br>docker run <span class="hljs-literal">-d</span> <span class="hljs-literal">--name</span> nginx <span class="hljs-literal">-p</span> <span class="hljs-number">80</span>:<span class="hljs-number">80</span> nginx<br><br><span class="hljs-comment"># 第5步，查看运行中容器</span><br>docker <span class="hljs-built_in">ps</span><br><span class="hljs-comment"># 也可以加格式化方式访问，格式会更加清爽</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">--format</span> <span class="hljs-string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><br><span class="hljs-comment"># 第6步，访问网页，地址：http://虚拟机地址</span><br><br><span class="hljs-comment"># 第7步，停止容器</span><br>docker stop nginx<br><br><span class="hljs-comment"># 第8步，查看所有容器</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">--format</span> <span class="hljs-string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><br><span class="hljs-comment"># 第9步，再次启动nginx容器</span><br>docker <span class="hljs-built_in">start</span> nginx<br><br><span class="hljs-comment"># 第10步，再次查看容器</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">--format</span> <span class="hljs-string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><br><span class="hljs-comment"># 第11步，查看容器详细信息</span><br>docker inspect nginx<br><br><span class="hljs-comment"># 第12步，进入容器,查看容器内目录</span><br>docker exec <span class="hljs-literal">-it</span> nginx bash<br><span class="hljs-comment"># 或者，可以进入MySQL</span><br>docker exec <span class="hljs-literal">-it</span> mysql mysql <span class="hljs-literal">-uroot</span> <span class="hljs-literal">-p</span><br><br><span class="hljs-comment"># 第13步，删除容器</span><br>docker <span class="hljs-built_in">rm</span> nginx<br><span class="hljs-comment"># 发现无法删除，因为容器运行中，强制删除容器</span><br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> nginx<br></code></pre></td></tr></table></figure><h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><p>给常用Docker命令起别名，方便我们访问：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-comment"># 修改/root/.bashrc文件</span><br>vi /root/.bashrc<br>内容如下：<br><span class="hljs-comment"># .bashrc</span><br><br><span class="hljs-comment"># User specific aliases and functions</span><br><br>alias <span class="hljs-built_in">rm</span>=<span class="hljs-string">&#x27;rm -i&#x27;</span><br>alias <span class="hljs-built_in">cp</span>=<span class="hljs-string">&#x27;cp -i&#x27;</span><br>alias <span class="hljs-built_in">mv</span>=<span class="hljs-string">&#x27;mv -i&#x27;</span><br>alias dps=<span class="hljs-string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span><br>alias dis=<span class="hljs-string">&#x27;docker images&#x27;</span><br><br><span class="hljs-comment"># Source global definitions</span><br><span class="hljs-keyword">if</span> [ -<span class="hljs-type">f</span> /<span class="hljs-type">etc</span>/<span class="hljs-type">bashrc</span> ]; then<br>        . /etc/bashrc<br>fi<br></code></pre></td></tr></table></figure><p>然后，执行命令使别名生效</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">source /root/.bashrc<br></code></pre></td></tr></table></figure><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便。大家思考几个问题：</p><ul><li>如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</li><li>MySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？</li><li>我想要让Nginx代理我的静态资源怎么办？</li></ul><p>因此，容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器</strong>解耦。</p><p>eg.当我通过docker下载了nginx，我需要修改内部的html静态文件，这时正常就需要进入docker内部，修改，但是内部没有提供vim相关命令，就需要使用数据卷，将html文件映射到外部进行修改，这样就可以同步到内部。</p><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机</strong>目录之间映射的桥梁。</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20241009163705279.png" alt="image-20241009163705279"></p><p>在上图中：</p><ul><li>我们创建了两个数据卷：<code>conf</code>、<code>html</code></li><li>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</li><li>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</li></ul><p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内的<code>/usr/share/nginx/html/_data</code>目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</p><p>注: <code>/var/lib/docker/volumes</code>这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为<code>/数据卷名/_data</code>。</p><h4 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h4><p>数据卷的相关命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker volume create</td><td align="left">创建数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="left">docker volume ls</td><td align="left">查看所有数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker volume rm</td><td align="left">删除指定数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker volume inspect</td><td align="left">查看某个数据卷的详情</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="left">docker volume prune</td><td align="left">清除数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><p>注意：<font color='pink'>容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。</font>而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-comment"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span><br>docker run <span class="hljs-literal">-d</span> <span class="hljs-literal">--name</span> nginx <span class="hljs-literal">-p</span> <span class="hljs-number">80</span>:<span class="hljs-number">80</span> <span class="hljs-literal">-v</span> html:/usr/share/nginx/html nginx<br><span class="hljs-comment">#-v 数据卷名：挂载目录</span><br><br><br><span class="hljs-comment"># 2.然后查看数据卷</span><br>docker volume <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 结果</span><br>DRIVER    VOLUME NAME<br>local     <span class="hljs-number">29524</span>ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f<br>local     html<br><br><span class="hljs-comment"># 3.查看数据卷详情</span><br>docker volume inspect html<br><span class="hljs-comment"># 结果</span><br>[<br>    &#123;<br>        <span class="hljs-string">&quot;CreatedAt&quot;</span>: <span class="hljs-string">&quot;2024-05-17T19:57:08+08:00&quot;</span>,<br>        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>        <span class="hljs-string">&quot;Labels&quot;</span>: <span class="hljs-type">null</span>,<br>        <span class="hljs-string">&quot;Mountpoint&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,<br>        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;html&quot;</span>,<br>        <span class="hljs-string">&quot;Options&quot;</span>: <span class="hljs-type">null</span>,<br>        <span class="hljs-string">&quot;Scope&quot;</span>: <span class="hljs-string">&quot;local&quot;</span><br>    &#125;<br>]<br><br><span class="hljs-comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span><br>ll /var/lib/docker/volumes/html/_data<br><span class="hljs-comment"># 可以看到与nginx的html目录内容一样，结果如下：</span><br>总用量 <span class="hljs-number">8</span><br><span class="hljs-literal">-rw-r--r--</span>. <span class="hljs-number">1</span> root root <span class="hljs-number">497</span> <span class="hljs-number">12</span>月 <span class="hljs-number">28</span> <span class="hljs-number">2021</span> <span class="hljs-number">50</span>x.html<br><span class="hljs-literal">-rw-r--r--</span>. <span class="hljs-number">1</span> root root <span class="hljs-number">615</span> <span class="hljs-number">12</span>月 <span class="hljs-number">28</span> <span class="hljs-number">2021</span> index.html<br><br><span class="hljs-comment"># 5.进入该目录，并随意修改index.html内容</span><br><span class="hljs-built_in">cd</span> /var/lib/docker/volumes/html/_data<br>vi index.html<br><br><span class="hljs-comment"># 6.打开页面，查看效果</span><br><br><span class="hljs-comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span><br>docker exec <span class="hljs-literal">-it</span> nginx bash<br></code></pre></td></tr></table></figure><h4 id="挂载本地目录或文件"><a href="#挂载本地目录或文件" class="headerlink" title="挂载本地目录或文件"></a>挂载本地目录或文件</h4><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 挂载本地目录</span><br>-v 本地目录:容器内目录<br><span class="hljs-comment"># 挂载本地文件</span><br>-v 本地文件:容器内文件<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">-v mysql:/var/lib/mysql <span class="hljs-comment"># 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷</span><br>-v ./mysql:/var/lib/mysql <span class="hljs-comment"># 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录</span><br></code></pre></td></tr></table></figure><p><strong>教学演示</strong>，删除并重新创建mysql容器，并完成本地目录挂载：</p><ul><li>挂载<code>/root/mysql/data</code>到容器内的<code>/var/lib/mysql</code>目录</li><li>挂载<code>/root/mysql/init</code>到容器内的<code>/docker-entrypoint-initdb.d</code>目录（初始化的SQL脚本目录）</li><li>挂载<code>/root/mysql/conf</code>到容器内的<code>/etc/mysql/conf.d</code>目录（这个是MySQL配置文件目录）</li></ul><p>接下来，我们演示本地目录挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 1.删除原来的MySQL容器</span><br>docker <span class="hljs-built_in">rm</span> -f mysql<br><br><span class="hljs-comment"># 2.进入root目录</span><br><span class="hljs-built_in">cd</span> ~<br><br><span class="hljs-comment"># 3.创建并运行新mysql容器，挂载本地目录</span><br>docker run -d \<br>  --name mysql \<br>  -p 3306:3306 \<br>  -e TZ=Asia/Shanghai \<br>  -e MYSQL_ROOT_PASSWORD=123 \<br>  -v ./mysql/data:/var/lib/mysql \<br>  -v ./mysql/conf:/etc/mysql/conf.d \<br>  -v ./mysql/init:/docker-entrypoint-initdb.d \<br>  mysql<br><br><span class="hljs-comment"># 4.查看root目录，可以发现~/mysql/data目录已经自动创建好了</span><br><span class="hljs-built_in">ls</span> -l mysql<br><span class="hljs-comment"># 结果：</span><br>总用量 4<br>drwxr-xr-x. 2 root    root   20 5月  19 15:11 conf<br>drwxr-xr-x. 7 polkitd root 4096 5月  19 15:11 data<br>drwxr-xr-x. 2 root    root   23 5月  19 15:11 init<br><br><span class="hljs-comment"># 查看data目录，会发现里面有大量数据库数据，说明数据库完成了初始化</span><br><span class="hljs-built_in">ls</span> -l data<br><br><span class="hljs-comment"># 5.查看MySQL容器内数据</span><br><span class="hljs-comment"># 5.1.进入MySQL</span><br>docker <span class="hljs-built_in">exec</span> -it mysql mysql -uroot -p123<br><span class="hljs-comment"># 5.2.查看编码表</span><br>show variables like <span class="hljs-string">&quot;%char%&quot;</span>;<br><span class="hljs-comment"># 5.3.结果，发现编码是utf8mb4没有问题</span><br>+--------------------------+--------------------------------+<br>| Variable_name            | Value                          |<br>+--------------------------+--------------------------------+<br>| character_set_client     | utf8mb4                        |<br>| character_set_connection | utf8mb4                        |<br>| character_set_database   | utf8mb4                        |<br>| character_set_filesystem | binary                         |<br>| character_set_results    | utf8mb4                        |<br>| character_set_server     | utf8mb4                        |<br>| character_set_system     | utf8mb3                        |<br>| character_sets_dir       | /usr/share/mysql-8.0/charsets/ |<br>+--------------------------+--------------------------------+<br><br></code></pre></td></tr></table></figure><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>前面我们一直在使用别人准备好的镜像，那如果我要部署一个Java项目，把它打包为一个镜像该怎么做呢</p><h4 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h4><p>要想自己构建镜像，必须先了解镜像的结构。</p><p>之前我们说过，镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。</p><p>因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</p><p>举个例子，我们要从0部署一个Java应用，大概流程是这样：</p><ul><li>准备一个linux服务（CentOS或者Ubuntu均可）</li><li>安装并配置JDK</li><li>上传Jar包</li><li>运行jar包</li></ul><p>那因此，我们打包镜像也是分成这么几步：</p><ul><li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20241010210831229.png" alt="image-20241010210831229"></p><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其对应的语法可以参考官方文档：</p><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><p>其中的语法比较多，比较常用的有：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>例如，要基于Ubuntu镜像来构建一个Java应用，其Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-comment"># 指定基础镜像</span><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">16.04</span><br><span class="hljs-comment"># 配置环境变量，JDK的安装目录、容器内时区</span><br><span class="hljs-keyword">ENV</span> JAVA_DIR=/usr/local<br><span class="hljs-keyword">ENV</span> TZ=Asia/Shanghai<br><span class="hljs-comment"># 拷贝jdk和java项目的包</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="hljs-variable">$JAVA_DIR</span>/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span><br><span class="hljs-comment"># 设定时区</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">ln</span> -snf /usr/share/zoneinfo/<span class="hljs-variable">$TZ</span> /etc/localtime &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$TZ</span> &gt; /etc/timezone</span><br><span class="hljs-comment"># 安装JDK</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> <span class="hljs-variable">$JAVA_DIR</span> \</span><br><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span><br><span class="language-bash"> &amp;&amp; <span class="hljs-built_in">mv</span> ./jdk1.8.0_144 ./java8</span><br><span class="hljs-comment"># 配置环境变量</span><br><span class="hljs-keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8<br><span class="hljs-keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin<br><span class="hljs-comment"># 指定项目监听的端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-comment"># 入口，java项目的启动命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>以后我们会有很多很多java项目需要打包为镜像，他们都需要Linux系统环境、JDK环境这两层，只有上面的3层不同（因为jar包不同）。如果每次制作java镜像都重复制作前两层镜像，是不是很麻烦。</p><p>所以，就有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-comment"># 基础镜像</span><br><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">11.0</span>-jre-buster<br><span class="hljs-comment"># 设定时区</span><br><span class="hljs-keyword">ENV</span> TZ=Asia/Shanghai<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">ln</span> -snf /usr/share/zoneinfo/<span class="hljs-variable">$TZ</span> /etc/localtime &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$TZ</span> &gt; /etc/timezone</span><br><span class="hljs-comment"># 拷贝jar包</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span><br><span class="hljs-comment"># 入口</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像了。</p><p>首先，我们将课前资料提供的<code>docker-demo.jar</code>包以及<code>Dockerfile</code>拷贝到虚拟机的<code>/root/demo</code>目录：</p><p>然后，执行命令，构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 进入镜像目录</span><br><span class="hljs-built_in">cd</span> /root/demo<br><span class="hljs-comment"># 开始构建</span><br>docker build -t docker-demo:1.0 .<br></code></pre></td></tr></table></figure><p>命令说明：</p><ul><li><code>docker build </code>: 就是构建一个docker镜像</li><li><code>-t docker-demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</li><li><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 直接指定Dockerfile目录</span><br>docker build -t docker-demo:1.0 /root/demo<br></code></pre></td></tr></table></figure><p>然后尝试运行该镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 1.创建并运行容器</span><br>docker run -d --name <span class="hljs-built_in">dd</span> -p 8080:8080 docker-demo:1.0<br><span class="hljs-comment"># 2.查看容器</span><br>dps<br><span class="hljs-comment"># 结果</span><br>CONTAINER ID   IMAGE             PORTS                                                  STATUS         NAMES<br>78a000447b49   docker-demo:1.0   0.0.0.0:8080-&gt;8080/tcp, :::8090-&gt;8090/tcp              Up 2 seconds   <span class="hljs-built_in">dd</span><br>f63cfead8502   mysql             0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   Up 2 hours     mysql<br><br><span class="hljs-comment"># 3.访问</span><br>curl localhost:8080/hello/count<br><span class="hljs-comment"># 结果：</span><br>&lt;h5&gt;欢迎访问黑马商城, 这是您第1次访问&lt;h5&gt;<br></code></pre></td></tr></table></figure><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>上节课我们创建了一个Java项目的容器，而Java项目往往需要访问其它各种中间件，例如MySQL、Redis等。现在，我们的容器之间能否互相访问呢？我们来测试一下</p><p>首先，我们查看下MySQL容器的详细信息，重点关注其中的网络IP地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 1.用基本命令，寻找Networks.bridge.IPAddress属性</span><br>docker inspect mysql<br><span class="hljs-comment"># 也可以使用format过滤结果</span><br>docker inspect --format=<span class="hljs-string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;println .IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> mysql<br><span class="hljs-comment"># 得到IP地址如下：</span><br>172.17.0.2<br><br><span class="hljs-comment"># 2.然后通过命令进入dd容器</span><br>docker <span class="hljs-built_in">exec</span> -it <span class="hljs-built_in">dd</span> bash<br><br><span class="hljs-comment"># 3.在容器内，通过ping命令测试网络</span><br>ping 172.17.0.2<br><span class="hljs-comment"># 结果</span><br>PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.<br>64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 <span class="hljs-keyword">time</span>=0.053 ms<br>64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 <span class="hljs-keyword">time</span>=0.059 ms<br>64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 <span class="hljs-keyword">time</span>=0.058 ms<br></code></pre></td></tr></table></figure><p>发现可以互联，没有问题。</p><p>但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</p><p>所以，我们必须借助于docker的网络功能来解决这个问题，官方文档：</p><p><a href="https://docs.docker.com/engine/reference/commandline/network/">https://docs.docker.com/engine/reference/commandline/network/</a></p><p>常见命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker network create</td><td align="left">创建一个网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="left">docker network ls</td><td align="left">查看所有网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker network rm</td><td align="left">删除指定网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="left">docker network prune</td><td align="left">清除未使用的网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker network connect</td><td align="left">使指定容器连接加入某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="left">docker network disconnect</td><td align="left">使指定容器连接离开某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="left">docker network inspect</td><td align="left">查看网络详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><p>教学演示：自定义网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 1.首先通过命令创建一个网络</span><br>docker network create hmall<br><br><span class="hljs-comment"># 2.然后查看网络</span><br>docker network <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 结果：</span><br>NETWORK ID     NAME      DRIVER    SCOPE<br>639bc44d0a87   bridge    bridge    <span class="hljs-built_in">local</span><br>403f16ec62a2   hmall     bridge    <span class="hljs-built_in">local</span><br>0dc0f72a0fbb   host      host      <span class="hljs-built_in">local</span><br>cd8d3e8df47b   none      null      <span class="hljs-built_in">local</span><br><span class="hljs-comment"># 其中，除了hmall以外，其它都是默认的网络</span><br><br><span class="hljs-comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span><br><span class="hljs-comment"># 这样该网络内的其它容器可以用别名互相访问！</span><br><span class="hljs-comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span><br>docker network connect hmall mysql --<span class="hljs-built_in">alias</span> db<br><span class="hljs-comment"># 3.2.db容器，也就是我们的java项目</span><br>docker network connect hmall <span class="hljs-built_in">dd</span><br><br><span class="hljs-comment"># 4.进入dd容器，尝试利用别名访问db</span><br><span class="hljs-comment"># 4.1.进入容器</span><br>docker <span class="hljs-built_in">exec</span> -it <span class="hljs-built_in">dd</span> bash<br><span class="hljs-comment"># 4.2.用db别名访问</span><br>ping db<br><span class="hljs-comment"># 结果</span><br>PING db (172.18.0.2) 56(84) bytes of data.<br>64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 <span class="hljs-keyword">time</span>=0.070 ms<br>64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 <span class="hljs-keyword">time</span>=0.056 ms<br><span class="hljs-comment"># 4.3.用容器名访问</span><br>ping mysql<br><span class="hljs-comment"># 结果：</span><br>PING mysql (172.18.0.2) 56(84) bytes of data.<br>64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 <span class="hljs-keyword">time</span>=0.044 ms<br>64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 <span class="hljs-keyword">time</span>=0.054 ms<br></code></pre></td></tr></table></figure><p>OK，现在无需记住IP地址也可以实现容器互联了。</p><p><strong>总结</strong>：</p><ul><li>在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身</li><li>在同一个自定义网络中的容器，可以通过别名互相访问</li></ul><h3 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h3><p>大家可以看到，我们部署一个简单的java项目，其中包含3个容器：</p><ul><li>MySQL</li><li>Nginx</li><li>Java项目</li></ul><p>而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止3个。如果还像之前那样手动的逐一部署，就太麻烦了。</p><p>而Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>docker-compose.yml文件的基本语法可以参考官方文档：</p><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p><p>举例来说，用docker run部署MySQL的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker run -d \<br>  --name mysql \<br>  -p 3306:3306 \<br>  -e TZ=Asia/Shanghai \<br>  -e MYSQL_ROOT_PASSWORD=123 \<br>  -v ./mysql/data:/var/lib/mysql \<br>  -v ./mysql/conf:/etc/mysql/conf.d \<br>  -v ./mysql/init:/docker-entrypoint-initdb.d \<br>  --network hmall<br>  mysql<br></code></pre></td></tr></table></figure><p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.8&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./mysql/data:/var/lib/mysql&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">new</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">new:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">hmall</span><br></code></pre></td></tr></table></figure><p>对比如下：</p><table><thead><tr><th align="left"><strong>docker run 参数</strong></th><th align="left"><strong>docker compose 指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">–name</td><td align="left">container_name</td><td align="left">容器名称</td></tr><tr><td align="left">-p</td><td align="left">ports</td><td align="left">端口映射</td></tr><tr><td align="left">-e</td><td align="left">environment</td><td align="left">环境变量</td></tr><tr><td align="left">-v</td><td align="left">volumes</td><td align="left">数据卷配置</td></tr><tr><td align="left">–network</td><td align="left">networks</td><td align="left">网络</td></tr></tbody></table><p>黑马商城部署文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.8&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./mysql/data:/var/lib/mysql&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">hm-net</span><br>  <span class="hljs-attr">hmall:</span><br>    <span class="hljs-attr">build:</span> <br>      <span class="hljs-attr">context:</span> <span class="hljs-string">.</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">Dockerfile</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">hmall</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8080:8080&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">hm-net</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">nginx:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;18080:18080&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;18081:18081&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">hmall</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">hm-net</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">hm-net:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">hmall</span><br></code></pre></td></tr></table></figure><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><p>编写好docker-compose.yml文件，就可以部署项目了。常见的命令：</p><p><a href="https://docs.docker.com/compose/reference/">https://docs.docker.com/compose/reference/</a></p><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker compose [OPTIONS] [COMMAND]<br></code></pre></td></tr></table></figure><p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20241011153320905.png" alt="image-20241011153320905"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 1.进入root目录</span><br><span class="hljs-built_in">cd</span> /root<br><br><span class="hljs-comment"># 2.删除旧容器</span><br>docker <span class="hljs-built_in">rm</span> -f $(docker ps -qa)<br><br><span class="hljs-comment"># 3.删除hmall镜像</span><br>docker rmi hmall<br><br><span class="hljs-comment"># 4.清空MySQL数据</span><br><span class="hljs-built_in">rm</span> -rf mysql/data<br><br><span class="hljs-comment"># 5.启动所有, -d 参数是后台启动</span><br>docker compose up -d<br><span class="hljs-comment"># 结果：</span><br>[+] Building 15.5s (8/8) FINISHED<br> =&gt; [internal] load build definition from Dockerfile                                    0.0s<br> =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s<br> =&gt; [internal] load .dockerignore                                                       0.0s<br> =&gt; =&gt; transferring context: 2B                                                         0.0s<br> =&gt; [internal] load metadata <span class="hljs-keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s<br> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s<br> =&gt; [internal] load build context                                                       0.0s<br> =&gt; =&gt; transferring context: 98B                                                        0.0s<br> =&gt; CACHED [2/3] RUN <span class="hljs-built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="hljs-built_in">echo</span>   0.0s<br> =&gt; CACHED [3/3] COPY hm-service.jar /app.jar                                           0.0s<br> =&gt; exporting to image                                                                  0.0s<br> =&gt; =&gt; exporting layers                                                                 0.0s<br> =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s<br> =&gt; =&gt; naming to docker.io/library/root-hmall                                           0.0s<br>[+] Running 4/4<br> ✔ Network hmall    Created                                                             0.2s<br> ✔ Container mysql  Started                                                             0.5s<br> ✔ Container hmall  Started                                                             0.9s<br> ✔ Container nginx  Started                                                             1.5s<br><br><span class="hljs-comment"># 6.查看镜像</span><br>docker compose images<br><span class="hljs-comment"># 结果</span><br>CONTAINER           REPOSITORY          TAG                 IMAGE ID            SIZE<br>hmall               root-hmall          latest              32eebee16acd        362MB<br>mysql               mysql               latest              3218b38490ce        516MB<br>nginx               nginx               latest              605c77e624dd        141MB<br><br><span class="hljs-comment"># 7.查看容器</span><br>docker compose ps<br><span class="hljs-comment"># 结果</span><br>NAME                IMAGE               COMMAND                  SERVICE             CREATED             STATUS              PORTS<br>hmall               root-hmall          <span class="hljs-string">&quot;java -jar /app.jar&quot;</span>     hmall               54 seconds ago      Up 52 seconds       0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp<br>mysql               mysql               <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   mysql               54 seconds ago      Up 53 seconds       0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp<br>nginx               nginx               <span class="hljs-string">&quot;/docker-entrypoint.…&quot;</span>   nginx               54 seconds ago      Up 52 seconds       80/tcp, 0.0.0.0:18080-18081-&gt;18080-18081/tcp, :::18080-18081-&gt;18080-18081/tcp<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx反向代理和负载均衡</title>
    <link href="/2022/07/06/Nginx/"/>
    <url>/2022/07/06/Nginx/</url>
    
    <content type="html"><![CDATA[<p>对登录功能测试完毕后，接下来，我们思考一个问题：<strong>前端发送的请求，是如何请求到后端服务的？</strong></p><p>前端请求地址：<a href="http://localhost/api/employee/login">http://localhost/api/employee/login</a></p><p>后端接口地址：<a href="http://localhost:8080/admin/employee/login">http://localhost:8080/admin/employee/login</a></p><p> <strong>前端请求地址</strong><br> <strong>后端接口地址</strong></p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20240730150859434.png" alt="image-20240730150852736"><br><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20240730150859434.png" alt="image-20240730150859434"></p><p>很明显，两个地址不一致，那是如何请求到后端服务的呢？</p><p><img src="https://pub-5b119fadf3b54830aea823cfd820fc57.r2.dev/image-20240730150906729.png" alt="image-20240730150906729"></p><p><strong>1). nginx反向代理</strong></p><p><strong>nginx 反向代理</strong>，就是将前端发送的动态请求由 nginx 转发到后端服务器</p><p><strong>nginx 反向代理的好处：</strong></p><ul><li><p>提高访问速度</p><p>因为nginx本身可以进行缓存，如果访问的同一接口，并且做了数据缓存，nginx就直接可把数据返回，不需要真正地访问服务端，从而提高访问速度。</p></li><li><p>进行负载均衡</p><p>所谓负载均衡,就是把大量的请求按照我们指定的方式均衡的分配给集群中的每台服务器。</p></li><li><p>保证后端服务安全</p><p>因为一般后台服务地址不会暴露，所以使用浏览器不能直接访问，可以把nginx作为请求访问的入口，请求到达nginx后转发到具体的服务中，从而保证后端服务的安全。</p></li></ul><p>在nginx.conf</p><p><strong>nginx 反向代理的配置方式：</strong></p><p>server{<br>    listen 80;<br>    server_name localhost;</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx">server&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> localhost;<br>    <br>    <span class="hljs-section">location</span> /api/&#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://localhost:8080/admin/; <span class="hljs-comment">#反向代理</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>proxy_pass：</strong>该指令是用来设置代理服务器的地址，可以是主机名称，IP地址加端口号等形式。</p><p>如上代码的含义是：监听80端口号， 然后当我们访问 <a href="http://localhost/..%E8%BF%99%E6%A0%B7%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%AE%83%E4%BC%9A%E9%80%9A%E8%BF%87">http://localhost:80/api/../..这样的接口的时候，它会通过</a> location &#x2F;api&#x2F; {} 这样的反向代理到 <a href="http://localhost:8080/admin/%E4%B8%8A%E6%9D%A5%E3%80%82">http://localhost:8080/admin/上来。</a></p><p>接下来，进到nginx-1.20.2\conf，打开nginx配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 反向代理,处理管理端发送的请求</span><br><span class="hljs-section">location</span> /api/ &#123;<br><span class="hljs-attribute">proxy_pass</span>   http://localhost:8080/admin/;<br>    <span class="hljs-comment">#proxy_pass   http://webservers/admin/;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当在访问<a href="http://localhost/api/employee/login%EF%BC%8Cnginx%E6%8E%A5%E6%94%B6%E5%88%B0%E8%AF%B7%E6%B1%82%E5%90%8E%E8%BD%AC%E5%88%B0http://localhost:8080/admin/%EF%BC%8C%E6%95%85%E6%9C%80%E7%BB%88%E7%9A%84%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80%E4%B8%BAhttp://localhost:8080/admin/employee/login%EF%BC%8C%E5%92%8C%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%9C%B0%E5%9D%80%E4%B8%80%E8%87%B4%E3%80%82">http://localhost/api/employee/login，nginx接收到请求后转到http://localhost:8080/admin/，故最终的请求地址为http://localhost:8080/admin/employee/login，和后台服务的访问地址一致。</a></p><p><strong>2). nginx 负载均衡</strong></p><p>当如果服务以集群的方式进行部署时，那nginx在转发请求到服务器时就需要做相应的负载均衡。其实，负载均衡从本质上来说也是基于反向代理来实现的，最终都是转发请求。</p><p><strong>nginx 负载均衡的配置方式：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> webservers&#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.128:8080</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.129:8080</span>;<br>&#125;<br>server&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> localhost;<br>    <br>    <span class="hljs-section">location</span> /api/&#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://webservers/admin;<span class="hljs-comment">#负载均衡</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>upstream：</strong>如果代理服务器是一组服务器的话，我们可以使用upstream指令配置后端服务器组。</p><p>如上代码的含义是：监听80端口号， 然后当我们访问 <a href="http://localhost/..%E8%BF%99%E6%A0%B7%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%AE%83%E4%BC%9A%E9%80%9A%E8%BF%87">http://localhost:80/api/../..这样的接口的时候，它会通过</a> location &#x2F;api&#x2F; {} 这样的反向代理到 <a href="http://webservers/admin%EF%BC%8C%E6%A0%B9%E6%8D%AEwebservers%E5%90%8D%E7%A7%B0%E6%89%BE%E5%88%B0%E4%B8%80%E7%BB%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%A0%B9%E6%8D%AE%E8%AE%BE%E7%BD%AE%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5(%E9%BB%98%E8%AE%A4%E6%98%AF%E8%BD%AE%E8%AF%A2)%E8%BD%AC%E5%8F%91%E5%88%B0%E5%85%B7%E4%BD%93%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82">http://webservers/admin，根据webservers名称找到一组服务器，根据设置的负载均衡策略(默认是轮询)转发到具体的服务器。</a></p><p><strong>注：</strong>upstream后面的名称可自定义，但要上下保持一致。</p><p><strong>nginx 负载均衡策略：</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>轮询</td><td>默认方式</td></tr><tr><td>weight</td><td>权重方式，默认为1，权重越高，被分配的客户端请求就越多</td></tr><tr><td>ip_hash</td><td>依据ip分配方式，这样每个访客可以固定访问一个后端服务</td></tr><tr><td>least_conn</td><td>依据最少连接方式，把请求优先分配给连接数少的后端服务</td></tr><tr><td>url_hash</td><td>依据url分配方式，这样相同的url会被分配到同一个后端服务</td></tr><tr><td>fair</td><td>依据响应时间方式，响应时间短的服务将会被优先分配</td></tr></tbody></table><p>具体配置方式：</p><p><strong>轮询：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> webservers&#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.128:8080</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.129:8080</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>weight:</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> webservers&#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.128:8080</span> weight=<span class="hljs-number">90</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.129:8080</span> weight=<span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ip_hash:</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> webservers&#123;<br>    ip_hash;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.128:8080</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.129:8080</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>least_conn:</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> webservers&#123;<br>    least_conn;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.128:8080</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.129:8080</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>url_hash:</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> webservers&#123;<br>    <span class="hljs-attribute">hash</span> &amp;request_uri;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.128:8080</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.129:8080</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>fair:</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> webservers&#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.128:8080</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.100.129:8080</span>;<br>    fair;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
